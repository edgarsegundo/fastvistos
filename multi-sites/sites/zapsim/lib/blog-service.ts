/**
 * üö® AUTO-GENERATED FILE. DO NOT EDIT.
 * This file is generated by sync-blog.js and will be overwritten.
 * To customize, edit the template.
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ Designed for use within **Astro** project files.  ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 */

import { prisma } from './prisma.js';
import { siteConfig } from '../site-config.ts';

export class BlogService {
    // Cache the business_id from site config
    private static _businessId: string | null = null;

    // Get the business_id from site config (cached)
    private static getBusinessId(): string {
        if (this._businessId === null) {
            if (!siteConfig?.site?.business_id) {
                throw new Error(
                    'business_id not found in site configuration. Please ensure site-config.ts has a valid site.business_id.'
                );
            }
            this._businessId = siteConfig.site.business_id;
        }
        return this._businessId!;
    }

    // Get blog configuration (for dynamic title and other settings)
    static async getBlogConfigFromDb() {
        try {
            const businessId = this.getBusinessId();
            return await prisma.blog_config.findFirst({
                where: {
                    business_id: businessId,
                    is_removed: false,
                },
            });
        } catch (error) {
            console.error('Error fetching blog config:', error);
            return null;
        }
    }

    // Get all published articles with their topics
    static async getPublishedArticles() {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findMany({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    published: {
                        lte: now, // Published date is less than or equal to now
                    },
                },
                include: {
                    blog_topic: true,
                },
                orderBy: {
                    published: 'desc',
                },
            });
        } catch (error) {
            console.error('Error fetching published articles:', error);
            return [];
        }
    }

    // Get article by slug
    static async getArticleBySlugFromDb(slug: string) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findFirst({
                where: {
                    slug: slug,
                    business_id: businessId,
                    is_removed: false,
                    published: {
                        lte: now,
                    },
                },
                include: {
                    blog_topic: true,
                },
            });
        } catch (error) {
            console.error('Error fetching article by slug:', error);
            return null;
        }
    }

    // Get article by ID
    static async getArticleById(id: string) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findFirst({
                where: {
                    id: id,
                    business_id: businessId,
                    is_removed: false,
                    published: {
                        lte: now,
                    },
                },
                include: {
                    blog_topic: true,
                },
            });
        } catch (error) {
            console.error('Error fetching article by ID:', error);
            return null;
        }
    }

    // Get all topics
    static async getTopics() {
        try {
            const businessId = this.getBusinessId();
            return await prisma.blog_topic.findMany({
                where: {
                    business_id: businessId,
                    is_removed: false,
                },
                orderBy: {
                    order: 'asc',
                },
            });
        } catch (error) {
            console.error('Error fetching topics:', error);
            return [];
        }
    }

    // Get articles by topic
    static async getArticlesByTopic(topicSlug: string) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findMany({
                where: {
                    business_id: businessId,
                    blog_topic: {
                        slug: topicSlug,
                        business_id: businessId,
                        is_removed: false,
                    },
                    is_removed: false,
                    published: {
                        lte: now,
                    },
                },
                include: {
                    blog_topic: true,
                },
                orderBy: {
                    published: 'desc',
                },
            });
        } catch (error) {
            console.error('Error fetching articles by topic:', error);
            return [];
        }
    }

    // Get recent articles (for sidebar, homepage, etc.)
    static async getRecentArticles(limit: number = 5) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findMany({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    published: {
                        lte: now,
                    },
                },
                include: {
                    blog_topic: true,
                },
                orderBy: {
                    published: 'desc',
                },
                take: limit,
            });
        } catch (error) {
            console.error('Error fetching recent articles:', error);
            return [];
        }
    }

    // Get topics with their articles for carousel display
    // If limit is provided, only return that number of articles per topic (newest first)
    static async getTopicsWithArticles(limit?: number) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_topic.findMany({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    blog_article: {
                        some: {
                            business_id: businessId,
                            is_removed: false,
                            published: {
                                lte: now,
                            },
                        },
                    },
                },
                include: {
                    blog_article: {
                        where: {
                            business_id: businessId,
                            is_removed: false,
                            published: {
                                lte: now,
                            },
                        },
                        orderBy: {
                            published: 'desc',
                        },
                        ...(limit ? { take: limit } : {}),
                    },
                },
                orderBy: {
                    order: 'asc',
                },
            });
        } catch (error) {
            console.error('Error fetching topics with articles:', error);
            return [];
        }
    }

    /**
     * Get topics to show on homepage, ordered by 'order'.
     * Only topics with show_on_homepage = true and is_removed = false.
     */
    static async getHomepageTopics() {
        try {
            const businessId = this.getBusinessId();
            return await prisma.blog_topic.findMany({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    show_on_homepage: true,
                },
                orderBy: {
                    order: 'asc',
                },
            });
        } catch (error) {
            console.error('Error fetching homepage topics:', error);
            return [];
        }
    }

    // Get articles with optional site filtering (for multi-site support)
    static async getArticles(siteId?: string, limit?: number) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findMany({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    published: {
                        lte: now, // Published date is less than or equal to now
                    },
                },
                include: {
                    blog_topic: true,
                },
                orderBy: {
                    published: 'desc',
                },
                ...(limit && { take: limit }),
            });
        } catch (error) {
            console.error('Error fetching articles:', error);
            return [];
        }
    }

    /**
     * Get the article to show in the hero section (show_in_hero = true).
     * Returns the most recent published article with show_in_hero, or null if none.
     */
    static async getShowInHeroArticle() {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findFirst({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    show_in_hero: true,
                    published: {
                        lte: now,
                    },
                },
                orderBy: {
                    published: 'desc',
                },
                include: {
                    blog_topic: true,
                },
            });
        } catch (error) {
            console.error('Error fetching show_in_hero article:', error);
            return null;
        }
    }

    /**
     * Get up to `limit` most read articles, filling with non-most_read/non-show_in_hero if needed.
     * When `debugFill` is true, the result is always padded to `limit`
     * by repeating the first available article (for testing only).
     */
    static async getMostReadArticles(
        limit: number = 12,
        debugFill: boolean = false
    ) {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();

            // Helper to fetch articles
            const fetchArticles = (params: Parameters<typeof prisma.blog_article.findMany>[0]) =>
                prisma.blog_article.findMany({
                    ...params,
                    include: { blog_topic: true },
                });

            // 1. Most-read articles (newest first)
            const mostRead = await fetchArticles({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    most_read: true,
                    published: { lte: now },
                    image_vertical: null,
                },
                orderBy: { published: 'desc' },
                take: limit,
            });

            let articles = [...mostRead];

            // 2. Fill with non-most_read & non-hero if needed
            if (articles.length < limit) {
                const needed = limit - articles.length;

                const filler = await fetchArticles({
                    where: {
                        business_id: businessId,
                        is_removed: false,
                        most_read: false,
                        show_in_hero: false,
                        published: { lte: now },
                    },
                    orderBy: { published: 'asc' },
                    take: needed,
                });

                articles.push(...filler);
            }

            // 3. Debug: force completion to `limit` by repeating one article
            if (debugFill && articles.length > 0 && articles.length < limit) {
                const articleToRepeat = articles[0]; // deterministic choice
                while (articles.length < limit) {
                    articles.push(articleToRepeat);
                }
            }

            return articles.slice(0, limit);
        } catch (error) {
            console.error('Error fetching most read articles:', error);
            return [];
        }
    }

    /**
     * Get the most recent article with most_read = true and image_vertical = true.
     * Returns one article or null if none found.
     */
    static async getArticleWithVerticalImage() {
        try {
            const businessId = this.getBusinessId();
            const now = new Date();
            return await prisma.blog_article.findFirst({
                where: {
                    business_id: businessId,
                    is_removed: false,
                    most_read: true,
                    image_vertical: { not: null, notIn: [''] },
                    published: {
                        lte: now,
                    },
                },
                include: {
                    blog_topic: true,
                },
                orderBy: {
                    published: 'desc',
                },
            });
        } catch (error) {
            console.error('Error fetching article with vertical image:', error);
            return null;
        }
    }    

    /**
     * Create a new blog article.
     * @param data Partial<blog_article> - All required fields for creation.
     * @returns The created blog_article record.
     */
    static async createBlogArticle(data: {
        id: string,
        title: string,
        content_md?: string,
        type: string,
        slug?: string,
        published?: Date,
        image?: string,
        business_id?: string,
        blog_topic_id: string,
        seo_description?: string,
        seo_image_caption?: string,
        seo_image_height?: number,
        seo_image_width?: number
        // faq_json?: any,
    }) {
        try {
            const now = new Date();
            const businessId = data.business_id || this.getBusinessId();

            const article = await prisma.blog_article.create({
                data: {
                    id: data.id,
                    created: now,
                    modified: now,
                    is_removed: false,
                    title: data.title,
                    content_md: data.content_md,
                    type: data.type,
                    slug: data.slug,
                    published: data.published,
                    image: data.image,
                    business_id: businessId,
                    blog_topic_id: data.blog_topic_id,
                    seo_description: data.seo_description,
                    seo_image_caption: data.seo_image_caption,
                    seo_image_height: data.seo_image_height,
                    seo_image_width: data.seo_image_width,
                    // faq_json: data.faq_json,
                }
            });
            return article;
        } catch (error) {
            console.error('Error creating blog article:', error);
            throw error;
        }
    }
    // Format date for display
    static formatDate(date: Date | string | null | undefined, locale: string = 'pt-BR'): string {
        if (!date) return 'Data n√£o dispon√≠vel';

        try {
            const dateObj = typeof date === 'string' ? new Date(date) : date;
            return dateObj.toLocaleDateString(locale, {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
            });
        } catch (error) {
            console.error('Error formatting date:', error);
            return 'Data inv√°lida';
        }
    }
}
